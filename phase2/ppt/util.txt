util
메시지 교환 과정에서 json을 사용하는 이유는
경량화 되어 있고 포맷이 간단하며 파싱 자체도 빠르기 때문에
클라이언트와 서버 양쪽 모두 부담 없이 사용이 가능하기 때문이라고 판단했습니다.
즉 데이터를 전송하는데 최소한의 데이터를 전송하고자 함이라고 생각했습니다.

FileUtil

write : 매개변수로 넘어오는 file로 new FileWriter의 객체를 생성한다. FileWriter는 문자 기반 스트림으로 
데이터를 파일에 저장할 때 사용되는데 현재는 문자열 형태로 값이 넘어오기 때문에 저장이 가능하다.

read : inputStream으로 넘어온 파일의 텍스트를 읽고 buffer에 저장한 후 readLine() 메소드를 통해 
한번에 읽어온다. 물론 buffer 없이도 외부 장치와의 데이터 입출력이 가능하지만, 
하드디스크의 속도가 매우 느린점 그리고 키보드 모니터와 같은 외부장치의 속도는 시간이 더 많이 걸리는 작업임을 감안했을때 중간에 메모리 버퍼를 통해 데이터를 한데 묶어 이동시켜 성능적으로 효율을 보이고 빠른 작업을 수행할 수 있음으로 판단됩니다. 
파일에서 읽어온 값들은 character array 형식으로 변환해 return 된다.


byteUtil의 경우 
 메모리에 상주되어 있는 객체 데이터를 바이트 형태로 변환 또는 바이트 형태의 데이터를 원시 타입으로 변환해주는 역할을 합니다. 

여기서 16진수와 비트 연산자를 통해 문자열 변환을 사용한 이유는 바이트형은 8비트의 공간을, int를 예시로 들었을때 int는 32비트의 공간을 차지하는데 byte를 int로 16진수로 통해 비트를 확장하는 경우
가장 앞의 비트가 0일 경우 0으로 나머지가 채워지기 때문에 동일한 결과를 받아낼 수 있지만
가장 앞의 비트가 1일 경우 2의 보수법 처리 때문에 모든 비트가 1로 채워지게 된다.
모든 비트가 1로 채워지게 되면 기존 값과 다른 int 값이 출력되게 되기 때문에 문제가 발생하게
되는데 이를 방지하기 위해 즉 계산과정에서 생기는 부호에 대한 처리를 하기 위함으로 볼 수 있습니다.
그러나 바이트에서 다른 데이터 타입이 아닌 반대 과정에서의 16진수 계산활용은 부호가
바뀌는 일이 없기 떄문에 무의미한것으로 보입니다.


SocketWorker

소켓워커의 경우 소켓 생성과 이 소켓에 대한 inputstream과 outputstream을 생성해 
데이터를 보내거나 읽기 위한 사전 준비를 하는 역할을 해줍니다.

이때 메시지를 읽는 경우 해당 메시지의 헤더 확인을 통해 해당 값의 데이터 타입을 판별해준 뒤 해당 타입으로 값을 변환해 손실되지 않고 원본과 동일한 체크섬된 메시지를 전달 받을 수 있습니다. 

byte 단위로 변환해서 보내는 이유
클라이언트 서버가 모두 java로 구현되어 있을 경우 데이터 타입이 자동으로 맞춰지기
떄문에 상관 없지만
C++의 경우 java의 object를 이해하지 못한다. 마찬가지로 Java 역시 C++의 구조체를 이해하지 못하기 때문에
서로 byte단위로 정보를 주고 받아야 한다. 



