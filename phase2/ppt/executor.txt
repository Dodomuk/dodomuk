쓰레드풀을 사용해야 하는 이유
-프로그램 성능 저하를 방지하기 위해.
-병렬처리를 위해 스레드를 생성 또는 수거하는 비용과 시간은 프로그램의 전체적인 퍼포먼스를
저하시킬수 있다.
-또한 서비스적 측면에서 다수의 사용자 요청을 수용하고 빠르게 처리하기 위해서는
쓰레드풀이 필요하다.
-

...그러나...
쓰레드를 알맞게 만들어두면 상관이 없으나 실제 요청과 병렬처리되는 쓰레드의 숫자보다
이미 만들어둔 쓰레드의 숫자가 더 많을 경우 나머지 쓰레드들은 아무일도 하지 않고
메모리만 소비하게 될 수 있어 낭비가 발생할 수 있다.
또한 쓰레드 별로 다른 테스크 시간을 가질 수 있는데 병렬로 일을 처리할 때
빨리 끝나는 쓰레드의 경우 아직 일하는 쓰레드를 기다릴수 있어 오버헤드가 발생할 수 있다.


추가된 점 : 
executorService ( 여러개의 작업을 효율적으로 처리하기 위해 제공되는 라이브러리)
==> 스레드를 생성해 작업을 처리하고 처리가 완료되면 스레드를 제거 하는 작업들을 해줌
- 스레드 풀(ThreadPool) 구현이 용이

ExecutorService 종류 3가지
-  CachedThreadPool : 필요에 따라 새 스레드를 생성 또는 이전에 생성된 스레드를 사용할 수 있을 경우 재사용하는 스레드풀.
                              짧은 비동기 작업을 실행 할 경우 성능 향상. 사용 가능한 스레드가 없을 경우 새 스레드가 생성되어 풀에 추가됨
                              60초 동안 사용되지 않은 스레드는 종료, 캐시에서 제거. 
                              어쩔 때는 일이 없고 어쩔 때는 일이 많아지는 경우 유기적으로 쓰레드의 숫자가 증가하고
                               감소할 수 있는 상황에서 활용하기 좋을거 같다.
-  FixedThreadPool : 고정된 수의 스레드를 재사용. 모든 스레드가 활성 상태일 경우 작업을 기다리는 스레드는 대기 상태.
                           작업이 완전히 종료될 때 까지 풀에 스레드는 존재한다. 비슷한 일이 반복될 경우 좋다고 생각된다.
- ScheduledThreadPool : 1분에 한번씩 임무를 수행시키기 위한 스레드 풀. 매초 반복되는 작업에 대한 1분 평균을 구할 때 용이 할 것 같다.

ForkJoinPool : newFixedThreadPool이나 newCachedThreadPool 같은
 ExecutorService의 구현체다. 그러나 특이한 점은 work-strealing 알고리즘이
구현되어 있다는 점이다. 
ForkJoinPool는 executor에서 newWorkStealingPool로 구현할 수 있다.
 

작업 처리 요청:
ExecutorService의 작업 큐에 Runnable 또는 Callable 객체를 넣는 행위
-execute() Runnable을 작업 큐에 저장
-submit() Runnable 또는 Callable을 작업 큐에 저장, Future 객체를 리턴
-submit 메소드를 사용하면 스레드의 생성 오버 헤드를 줄일수 있다. execute메소드는 작업 처리중
예외가 발생하면 사용중이던 스레드를 버리고 새로운 스레드를 생성한다. 그러나 submit 메소드는
쓰던 스레드를 재활용한다.        
==> https://sas-study.tistory.com/231

ExecutorService

Runnable : 쓰레드 도자적으로 작업을 처리할 수 있는 경우 Runnable 상속
Callable : 쓰레드의 리턴값이 필요할 경우


fixedThreadPool 사용시 해당 머신의 CPU 코어수를 기준으로 생성하면
 더 좋은 퍼포먼스를 얻을 수 있다고 생각

