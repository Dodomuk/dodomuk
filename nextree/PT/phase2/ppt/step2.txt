#2

파일 경로를 통한 생성 및 삭제 1000번 반복 과
socket설정 및 stream을 통한 서버와 클라이언트 
간의 파일 생성 및 삭제가 반복됩니다.  
쓰레드 숫자가 5의 배수로 늘어나 5,10 그리고 25까지 반복적으로 들어가게됩니다.
클라이언트측에서는 showStoreDemo 메소드를 통해 
자체적으로 통신 없이 clientTempFolder에 999개의 파일을
만들게 되고, 
클라이언트 측에서 보낸 메시지를 읽고 커맨드 명령어를 판단해 파일을 생성 또는 삭제하게 됩니다. 

스탭2 같은 경우 단일 쓰레드로 운용이되기 때문에 작업을 처리하는 쓰레드가 1개로 고정되어 있어 다른 스탭 보다 처리 시간이 상대적으로 길게 나타나는 현상을 볼 수 있었습니다.

getDispatcher를 통해 connect()하는
포트번호와 IP주소를 통해 커넥션이 되는 부분은 이해 할 수 있었다. 그러나 시스템에는 보통 많은 수의 프로세스가 동작되고 서버측에서 생성되는 소켓은 여러개가 있을텐데
시스템은 어떤 식별과정을 통해서 이 프로세스를 처리할 수 있는것일까에 대해 의문을
가졌습니다. 

보통 시스템에는 많은 수의 프로세스가 동작하는데 저희가 현재 사용 중인 TCP 프로토콜 혹은 UDP는 표준에 따라 각 소켓은 시스템이 관리하는 포트(0~65535)중 하나의 포트 번호를
사용하게 됩니다. 운영체제는 소켓들이 중복된 포트 번호를 사용하지 않도록 내부적으로
포트번호와 소켓 연결 정보를 관리할 것이고 bind() ap가 해당 소켓이 지정된 포트 번호를
사용할 것이라는 것을 운영체제에 요청할 것이고 만약 지정된 포트 번호를 다른 소켓이 사용중이라면 bind api()는 에러를 반환할 것입니다. 

이런 과정을 거쳐 서버 소켓과 포트 번호가 bind되고 나면 listen api를 통해 서버 소켓의
포트 번호로 클라이언트에서 연결 요청이 있는지 확인 하기 위해 대기 상태로 머무를 것이고 연결 요청이 확인 될 경우 데이터 송수신을 위한 새로운 소켓을 만들고 서버 소켓의 대기 큐에
쌓여 있는 첫 번째 연결 요청을 매핑시킬 것입니다. 

해당 쓰레드는 단일 쓰레드 형식으로 처리되며 쓰레드가 하나씩 처리되기 때문에
실제 처리 시간만을 지켜봐도 멀티쓰레드 형식으로 처리된 타 step보다  더 많은 시간이
투자된 것을 확인 할 수 있었습니다.


run 처리 시간 계산
1 9.800000
2.16.036000
3.23.862667
4.31.568800
5.39.687080

